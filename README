1:

Функция getpid() не имеет параметров и возвращает идентификатор текущего процесса.
Функция getppid() также не имеет параметров и возвращает идентификатор родительского процесса.
Функция printf() принимает форматированную строку и список аргументов. В данном случае форматированная строка содержит две строки: "ID текущего процесса: " и "ID родительского процесса: ". Символ %d используется для вставки значения переменной pid в первую строку, а значение переменной ppid - во вторую.

2:

Получаем идентификаторы текущего (pid) и родительского (ppid) процессов:
getpid(): возвращает идентификатор текущего процесса
getppid(): возвращает идентификатор родительского процесса
Печатаем идентификаторы:
printf("Идентификатор текущего процесса: %d\n", pid);
printf("Идентификатор родительского процесса: %d\n", ppid);
Создаем копию процесса с помощью fork():
fork() возвращает 0 в дочернем процессе и идентификатор дочернего процесса в родительском процессе.
Если fork() возвращает -1, произошла ошибка.
В дочернем процессе:
Обновляем pid и ppid с помощью getpid() и getppid().
Печатаем обновленные идентификаторы.
В родительском процессе:
Печатаем идентификатор дочернего процесса.
   
3.

Новый исполняемый файл:
Вам нужно создать новый исполняемый файл (new_process) с тем же функционалом, что и исходная программа (получение и вывод идентификаторов процессов).
Новый файл должен иметь те же функции (getpid() и getppid()) и печатать идентификаторы в том же формате.
Создание нового процесса с помощью execvp():
execvp() заменяет текущий процесс новым исполняемым файлом.


